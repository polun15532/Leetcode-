//給定一個數組其中有一個數出現一次，而其他的數出現三次找到他。
//這題直觀的做法是用哈希表去紀錄出現過的數，然後遍歷哈希表，但這樣空間複雜度是O(n)不符合題目說只允許常數的額外空間。
//因此我們換個思路，由於其他數出現三次，我們可以根據這個特性來求解。
//以int來說他有32個位元，我們從第一個位元開始遍歷數組假設出現位元值為1時就加入到臨時變數temp裡。
//由於其他數字會出現3次因此將temp%3後即可知道只出現一次的數其位元值是1還是0。

int singleNumber(int* nums, int numsSize) {
    int total=0,temp=0;
    for(int i=31;i>=0;i--){
        for(int j=0;j<numsSize;j++){
            temp+=nums[j]>>i&1;//右移i位後與1取&，可以得到第i位的位元值。
        }
        if (temp%3){
            total|=1u<<i;//用u轉成無符號整數(因為int第一個位元表正負因此不能把1左移31位)。
        }
        temp=0;
    }
    return total;
}
//時間複雜度 O(n)
//空間複雜度 O(1)
